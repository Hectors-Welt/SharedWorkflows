name: "Build docker image"
description: "Builds and publish docker image for the service"

inputs:
  service_name:
    description: "The name of the service"
    required: true
  environment:
    description: "The environment"
    required: true
  version:
    description: "The version"
    required: true
  base_version:
    description: "The base version"
    required: true
  staging_run_number:
    description: "The run number of the staging version (if exists)"
    required: true
  nexus_docker_username:
    description: "The username for the Nexus Docker registry"
    required: true
  nexus_docker_password:
    description: "The password for the Nexus Docker registry"
    required: true
  docker_registry:
    description: "The Docker registry URL"
    required: true
  nuget_github_host:
    description: "The GitHub NuGet host"
    required: true
  nuget_github_username:
    description: "The GitHub NuGet username"
    required: true
  nuget_github_password:
    description: "The GitHub NuGet password"
    required: true
  hangfire_feed_url:
    description: "The Hangfire feed URL"
    required: true
  hangfire_username:
    description: "The Hangfire username"
    required: true
  hangfire_password:
    description: "The Hangfire password"
    required: true
  working_directory:
    description: "The working directory for the service"
    required: true

runs:
  using: "composite"
  steps:
    - name: Log in to the Container registry
      uses: docker/login-action@v2
      with:
        registry: ${{ inputs.docker_registry }}
        username: ${{ inputs.nexus_docker_username }}
        password: ${{ inputs.nexus_docker_password }}

    - name: create docker file
      if: ${{inputs.service_name == 'AdminCenter.Devices' }}
      working-directory: ./${{inputs.working_directory}}
      run: |

        cat <<EOF >Dockerfile
        FROM mcr.microsoft.com/dotnet/aspnet:8.0 AS base
        WORKDIR /app
        EXPOSE 80
        # --------------------------
        # BUILD STAGE
        # --------------------------
        FROM mcr.microsoft.com/dotnet/sdk:8.0 AS build
        COPY ./ ./
        WORKDIR "/${{inputs.working_directory}}"

        # NuGet feeds
        RUN dotnet nuget add source ${{ inputs.nuget_github_host }} --name github --username ${{ inputs.nuget_github_username }} --password ${{ inputs.nuget_github_password }} --store-password-in-clear-text
        RUN dotnet nuget add source ${{ inputs.hangfire_feed_url }} --name hangfirePro --username ${{ inputs.hangfire_username }} --password ${{ inputs.hangfire_password }} --store-password-in-clear-text

        RUN dotnet restore
        RUN dotnet build "${{ inputs.service_name }}.csproj" -c Release -o /app/build

        # --------------------------
        # PUBLISH STAGE
        # --------------------------
        FROM build AS publish

        # Publish code
        RUN dotnet publish "${{ inputs.service_name }}.csproj" -c Release -o /app/publish \
            /p:AssemblyVersion=${{ inputs.version }} \
            /p:FileVersion=${{ inputs.version }}

        # Copy Playbooks manually into publish output
        COPY ${{ inputs.working_directory }}/Playbooks /app/publish/Playbooks

        # Optional: copy Ansible config into publish folder if needed
        # COPY ./Playbooks/ansible.cfg /app/publish/ansible.cfg

        # --------------------------
        # FINAL RUNTIME IMAGE
        # --------------------------
        FROM mcr.microsoft.com/dotnet/aspnet:8.0 AS final
        WORKDIR /app

        # Install Ansible + sshpass
        RUN apt-get update && \
            apt-get install -y ansible sshpass python3 python3-pip && \
            apt-get clean

        # Copy published app
        COPY --from=publish /app/publish .

        # Move ansible.cfg to standard location
        COPY ${{ inputs.working_directory }}/Playbooks/ansible.cfg /etc/ansible/ansible.cfg

        ENTRYPOINT [ "sh", "-c", "dotnet ${{ inputs.service_name }}.dll" ]

        EOF
        echo "Dockerfile created"
      shell: bash

    - name: create docker file default
      if: ${{inputs.service_name != 'AdminCenter.Devices' }}
      working-directory: ./${{inputs.working_directory}}
      run: |
        cat <<EOF >Dockerfile
        FROM mcr.microsoft.com/dotnet/aspnet:8.0 AS base
        WORKDIR /app
        EXPOSE 80
        FROM mcr.microsoft.com/dotnet/sdk:8.0 AS build
        COPY ./ .
        RUN ls -al
        WORKDIR "/${{inputs.working_directory}}/."
        RUN dotnet nuget add source ${{ inputs.nuget_github_host }} --name github --username ${{ inputs.nuget_github_username }} --password ${{ inputs.nuget_github_password }} --store-password-in-clear-text
        WORKDIR "/${{inputs.working_directory}}/."
        RUN dotnet nuget add source ${{ inputs.hangfire_feed_url }} --name hangfirePro --username ${{ inputs.hangfire_username }} --password ${{ inputs.hangfire_password }} --store-password-in-clear-text
        WORKDIR "/${{inputs.working_directory}}/."
        RUN dotnet restore
        WORKDIR "/${{inputs.working_directory}}/."
        RUN dotnet build "${{ inputs.service_name }}.csproj" -c Release -o /app/build
        FROM build AS publish
        RUN dotnet publish "${{ inputs.service_name }}.csproj" -c Release -o /app/publish /p:AssemblyVersion=${{ inputs.version }} /p:FileVersion=${{ inputs.version }}
        FROM base AS final
        WORKDIR /app
        COPY --from=publish /app/publish .
        ENTRYPOINT [ "sh", "-c", "dotnet ${{ inputs.service_name }}.dll" ]
        EOF
        echo "Dockerfile created"
      shell: bash

    - name: Get servicename to lowercase
      id: toLowerCase
      run: |
        INPUT=${{ inputs.service_name }}
        echo "lowerCaseValue=${INPUT,,}" >> $GITHUB_OUTPUT
      shell: bash

    - name: Get image path
      id: imagepath
      run: |
        DIR="${{inputs.working_directory}}/${{ inputs.service_name }}"
        SERVICE="${{inputs.service_name}}"
        SERVICE_TO_LOWER="${{steps.toLowerCase.outputs.lowerCaseValue}}"
        REG="${{ inputs.docker_registry }}"
        if [[ "$DIR" == *AdminCenter* ]]; then
          echo "image_path=${REG}/admincenter/${SERVICE}" >> $GITHUB_OUTPUT
          echo "image_path_to_lower=${REG}/admincenter/${SERVICE_TO_LOWER}" >> $GITHUB_OUTPUT
        else
          echo "image_path=${REG}/${SERVICE}" >> $GITHUB_OUTPUT
          echo "image_path_to_lower=${REG}/${SERVICE_TO_LOWER}" >> $GITHUB_OUTPUT
        fi
      shell: bash

    - name: Extract metadata (tags, labels) for Docker
      id: meta
      uses: docker/metadata-action@v2
      with:
        images: ${{ steps.imagepath.outputs.image_path }}
        flavor: |
          latest=false
        tags: |
          type=ref,event=tag

    - name: Build and push Docker image
      if: ${{ ( inputs.environment == 'release' ) }}
      uses: docker/build-push-action@v4
      with:
        context: .
        build-args: |
          SERVICE=${{ inputs.service_name }}
        push: true
        tags: ${{ steps.meta.outputs.tags }},  ${{ steps.imagepath.outputs.image_path_to_lower }}:release
        labels: ${{ steps.meta.outputs.labels }}
        file: ./${{inputs.working_directory}}/Dockerfile

    - name: Build and push Docker image
      if: ${{ ( inputs.environment == 'staging' ) }}
      uses: docker/build-push-action@v4
      with:
        context: .
        build-args: |
          SERVICE=${{ inputs.service_name }}
        push: true
        tags: ${{ steps.meta.outputs.tags }},  ${{ steps.imagepath.outputs.image_path_to_lower }}:staging
        labels: ${{ steps.meta.outputs.labels }}
        file: ./${{inputs.working_directory}}/Dockerfile

    - name: Build and push Docker image
      if: ${{ ( inputs.environment == 'prerelease' ) }}
      uses: docker/build-push-action@v4
      with:
        context: .
        build-args: |
          SERVICE=${{ inputs.service_name }}
        push: true
        tags: ${{ steps.meta.outputs.tags }},  ${{ steps.imagepath.outputs.image_path_to_lower }}:prerelease
        labels: ${{ steps.meta.outputs.labels }}
        file: ./${{inputs.working_directory}}/Dockerfile
